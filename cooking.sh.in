#!/bin/bash

#
# Copyright 2018 Jesse Haber-Kucharsky
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

#
# This is cmake-cooking v0.11.0
# The home of cmake-cooking is https://github.com/hakuch/CMakeCooking
#

set -e

CMAKE=${CMAKE:-cmake}

invoked_args=("$@")
source_dir="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
initial_wd=$(pwd)
memory_file="${initial_wd}/.cooking_memory"

recipe="${source_dir}/cooking_recipe.cmake"
declare -a excluded_ingredients
declare -a included_ingredients
build_dir="${initial_wd}/build"
build_type="Debug"
# Depends on `build_dir`.
ingredients_dir=""
generator="Ninja"
list_only=""
nested=""

usage() {
    cat <<EOF

Fetch, configure, build, and install dependencies ("ingredients") for a CMake project
in a local and repeatable development environment.

Usage: $0 [OPTIONS]

where OPTIONS are:

-a
-r RECIPE
-e INGREDIENT
-i INGREDIENT
-d BUILD_DIR (=${build_dir})
-p INGREDIENTS_DIR (=${build_dir}/_cooking/installed)
-t BUILD_TYPE (=${build_type})
-g GENERATOR (=${generator})
-s VAR=VALUE
-f EXPORT_DIR
-l
-h

By default, cmake-cooking reads a file called `cooking_recipe.cmake`.

If neither [-i] nor [-e] are specified with a recipe ([-r]), then all ingredients of the recipe
will be fetched and built.

[-i] and [-e] are mutually-exclusive options: only provide one.

Option details:

-a

    Invoke 'cooking.sh' with the arguments that were provided to it last time, instead
    of the arguments provided.

-r RECIPE

    Instead of reading the recipe in a file called `cooking_recipe.cmake`, use the named recipe.

    For a recipe named "foo", a file is expected to exist called `recipe/foo.cmake` relative to
    the source directory of the project.

-e INGREDIENT

    Exclude an ingredient from a recipe. This option can be supplied many times.

    For example, if a recipe consists of 'apple', 'banana', 'carrot', and 'donut', then

        ./cooking.sh -e apple -e donut

    will prepare 'banana' and 'carrot' but not prepare 'apple' and 'donut'.

    If an ingredient is excluded, then it is assumed that all ingredients that depend on it
    can satisfy that dependency in some other way from the system (ie, the dependency is
    removed internally).

-i INGREDIENT

    Include an ingredient from a recipe, ignoring the others. This option can be supplied
    many times.

    Similar to [-e], but the opposite.

    For example, if a recipe consists of 'apple', 'banana', 'carrot', and 'donut' then

        ./cooking.sh -i apple -i donut

    will prepare 'apple' and 'donut' but not prepare 'banana' and 'carrot'.

    If an ingredient is not in the "include-list", then it is assumed that all
    ingredients that are in the list and which depend on it can satisfy that dependency
    in some other way from the system.

-d BUILD_DIR (=${build_dir})

    Configure the project and build it in the named directory.

-p INGREDIENTS_DIR (=${build_dir}/_cooking/installed)

    Install compiled ingredients into this directory.

-t BUILD_TYPE (=${build_type})

    Configure all ingredients and the project with the named CMake build-type.
    An example build type is "Release".

-g GENERATOR (=${generator})

    Use the named CMake generator for building all ingredients and the project.
    An example generator is "Unix Makfiles".

-s VAR=VALUE

    Set an environmental variable 'VAR' to the value 'VALUE' during the invocation of CMake.

-f EXPORT_DIR

    If provided, and the project is successfully configured, then the tree of installed ingredients
    is exported to this directory (the actual files: not symbolic links).

    This option requires rsync.

    This may be useful for preparing continuous integration environments, but it is not
    recommended for distribution or release purposes (since this would be counter
    to the goal of cmake-cooking).

-l

    Only list available ingredients for a given recipe, and don't do anything else.

-h

    Show this help information and exit.

EOF
}

parse_assignment() {
    IFS='=' read -ra parts <<< "${1}"
    export "${parts[0]}"="${parts[1]}"
}

yell_include_exclude_mutually_exclusive() {
    echo "Cooking: [-e] and [-i] are mutually exclusive options!" >&2
}

while getopts "ar:e:i:d:p:t:g:s:f:lhx" arg; do
    case "${arg}" in
        a)
            if [ ! -f "${memory_file}" ]; then
                echo "No previous invocation found to recall!" >&2
                exit 1
            fi

            source "${memory_file}"
            run_previous && exit 0
            ;;
        r) recipe="${source_dir}/recipe/${OPTARG}.cmake" ;;
        e)
            if [[ ${#included_ingredients[@]} -ne 0 ]]; then
                yell_include_exclude_mutually_exclusive
                exit 1
            fi

            excluded_ingredients+=(${OPTARG})
            ;;
        i)
            if [[ ${#excluded_ingredients[@]} -ne 0 ]]; then
                yell_include_exclude_mutually_exclusive
                exit 1
            fi

            included_ingredients+=(${OPTARG})
            ;;
        d) build_dir=$(realpath "${OPTARG}") ;;
        p) ingredients_dir=$(realpath "${OPTARG}") ;;
        t) build_type=${OPTARG} ;;
        g) generator=${OPTARG} ;;
        s) parse_assignment "${OPTARG}" ;;
        f) export_dir=$(realpath "${OPTARG}") ;;
        l) list_only="1" ;;
        h) usage; exit 0 ;;
        x) nested="1" ;;
        *) usage; exit 1 ;;
    esac
done

shift $((OPTIND - 1))

cooking_dir="${build_dir}/_cooking"
cache_file="${build_dir}/CMakeCache.txt"
ingredients_ready_file="${cooking_dir}/ready.txt"

if [ -z "${ingredients_dir}" ]; then
    ingredients_dir="${cooking_dir}/installed"
fi

mkdir -p "${build_dir}"

cat <<'EOF' > "${build_dir}/Cooking.cmake"
#
# This file was generated by cmake-cooking v0.11.0
# The home of cmake-cooking is https://github.com/hakuch/CMakeCooking
#

### BEGIN GENERATED FILE
### END GENERATED FILE
EOF

cmake_cooking_args=(
    "-DCooking_INGREDIENTS_DIR=${ingredients_dir}"
    "-DCooking_RECIPE=${recipe}"
)

#
# Remove any `Cooking.cmake` file from the source directory. We now generate this file in the build directory, and old
# copies will cause conflicts.
#

old_cooking_file="${source_dir}/cmake/Cooking.cmake"

if [ -f "${old_cooking_file}" ]; then
    grep 'This file was generated by cmake-cooking' "${old_cooking_file}" > /dev/null && rm "${old_cooking_file}"
fi

#
# Clean-up from a previous run.
#

if [ -e "${ingredients_ready_file}" ]; then
    rm "${ingredients_ready_file}"
fi

if [ -e "${cache_file}" ]; then
    rm "${cache_file}"
fi

if [ -d "${ingredients_dir}" -a -z "${nested}" ]; then
    rm -r --preserve-root "${ingredients_dir}"
fi

mkdir -p "${ingredients_dir}"

#
# Validate recipe.
#

if [ -n "${recipe}" ]; then
    if [ ! -f "${recipe}" ]; then
        echo "Cooking: The '${recipe}' recipe file does not exist!" >&2
        exit 1
    fi
fi

#
# Prepare lists of included and excluded ingredients.
#

if [ -n "${excluded_ingredients}" ] && [ -z "${list_only}" ]; then
    cmake_cooking_args+=(
        -DCooking_EXCLUDED_INGREDIENTS=$(printf "%s;" "${excluded_ingredients[@]}")
        -DCooking_INCLUDED_INGREDIENTS=
    )
fi

if [ -n "${included_ingredients}" ] && [ -z "${list_only}" ]; then
    cmake_cooking_args+=(
        -DCooking_EXCLUDED_INGREDIENTS=
        -DCooking_INCLUDED_INGREDIENTS=$(printf "%s;" "${included_ingredients[@]}")
    )
fi

#
# Configure and build ingredients.
#

mkdir -p "${cooking_dir}"/stow
touch "${cooking_dir}"/stow/.stow
cd "${build_dir}"

declare -a build_args

if [ "${generator}" == "Ninja" ]; then
    build_args+=(-v)
fi

if [ -n "${list_only}" ]; then
    cmake_cooking_args+=("-DCooking_LIST_ONLY=ON")
fi

${CMAKE} -DCMAKE_BUILD_TYPE="${build_type}" "${cmake_cooking_args[@]}" -G "${generator}" "${source_dir}" "${@}"

if [ -n "${recipe}" ]; then
    ${CMAKE} --build . --target _cooking_ingredients_ready -- "${build_args[@]}"

    #
    # Report what we've done (if we're not nested).
    #

    if [ -z "${nested}" ]; then
        ingredients=($(find "${ingredients_dir}" -name '.cooking_ingredient_*' -printf '%f\n' | sed -r 's/\.cooking_ingredient_(.+)/\1/'))

        if [ -z "${list_only}" ]; then
            printf "\nCooking: Installed the following ingredients:\n"
        else
            printf "\nCooking: The following ingredients are necessary for this recipe:\n"
        fi

        for ingredient in "${ingredients[@]}"; do
            echo "  - ${ingredient}"
        done

        printf '\n'
    fi

    if [ -n "${list_only}" ]; then
        exit 0
    fi

    #
    # Configure the project, expecting all requirements satisfied.
    #

    ${CMAKE} -DCMAKE_FIND_PACKAGE_NO_PACKAGE_REGISTRY=ON "${@}" .

    #
    # Optionally export the installed files.
    #

    if [ -n "${export_dir}" ]; then
        rsync "${ingredients_dir}/" "${export_dir}" -a --copy-links
        printf "\nCooking: Exported ingredients to ${export_dir}\n"
    fi
fi

#
# Save invocation information.
#

cd "${initial_wd}"

cat <<EOF > "${memory_file}"
run_previous() {
    "${0}" ${invoked_args[@]@Q}
}
EOF
